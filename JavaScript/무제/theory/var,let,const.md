# 중복 선언 가능 여부
### var
- 중복해서 선언 및 초기화 가능
- 마지막에 할당된 값이 변수에 저장됨
### const, let
- 불가능
- 이미 선언한 변수를 다시 선언할 경우, 에러 발생
- var에 비해 코드 안정성 높음
# 재할당 가능 여부
### var, let
- 값이 재할당이 가능함
- 변수 선언 및 초기화 이후 반복해서 다른 값 재할당 가능
### const
- 값이 재할당이 불가능한 상수
- 상수를 선언하는 키워드
- var, let과 다르게 반드시 값을 선언과 동시에 정의해야 함
# 변수 스코프 유효범위
### 스코프란?
- 유효한 참조 범위
### var
- 함수 레벨 스코프 (function-level scope)
- 함수 내부에 선언된 변수만 지역변수로 한정하며, 나머지는 모두 전역변수로 간주
- if, for, while, try/catch 문 등 코드 블럭 `{ ... }` 내부에서 var로 선언된 변수를 전역 변수로 간주함
	- 블럭 외부에서도 어디서나 참조 가능
### let, const
- 블록 레벨 스코프 (block-level scope)
- 함수 내부는 물론 if문, for문 등 코드 블럭에서 선언된 변수도 지역 변수로 취급함
- 함수 내부, 블럭 내부에서 선언된 변수도 외부에서 참조 불가능
# 변수 호이스팅 방식
### 호이스팅이란?
- Javascript는 코드 실행 전, 일종의 '코드 평가 과정'을 거친다
- 이 때 변수 선언문을 미리 실행해두기 때문에 뒤에서 선언된 변수도 앞의 코드에서 참조 가능하게 되는 현상
### var
- 변수 호이스팅 발생
```js
console.log(a);  // undefined
var a = 10;
console.log(a); // 10
```
- 에러 발생 X
- 코드 실행 전 자바스크립트 엔진이 미리 다음과 같은 과정을 거침
	1. 변수 선언
	2. undefined로 초기화
### let, const
- 변수 호이스팅 발생
- var와는 다른 방식으로 작동
```js
console.log(a);  // ReferenceError: a is not defined
let a = 10;
```
- 에러 발생
- 호이스팅이 발생하지 않은 것처럼 보임
- 코드 실행 전
	1. 변수 선언
	2. 초기화는 코드 실행 과정에서 변수 선언문을 만났을 때 수행함
- 선언은 되었지만 초기화되지 않았기 때문에 호이스팅이 발생해도 값을 참조할 수 없어 발생하지 않는 것처럼 보임
#### TDZ(Temporal Dead Zone)
- 변수의 선언과 초기화 사이에 일시적으로 변수 값을 참조할 수 없는 구간
- 지역변수가 전역변수보다 우선 순위가 높음
```js
let a = 10;

if (true) {
	console.log(a);  // ReferenceError: a is not defined
	let a = 20;
}
```
- 전역변수 a가 선언되었음에도 지역변수 a를 참조하지 못해 에러 발생
# 전역객체 프로퍼티 여부
### var
- 전역객체(브라우저에서는 window)의 프로퍼티
```js
var a = 10;

console.log(window.a); // 10
console.log(a); // 10
```
### let, const
- 전역객체 프로퍼티가 아님
```js
let a = 10;

console.log(window.a); // undefined
console.log(a); // 10
```