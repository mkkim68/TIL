# 1월 월말평가 준비
## 데이터 구조
- 메서드 : 객체에 속한 함수
	- 클래스 내부에 정의되는 함수
	- 데이터 타입이 호출 (객체.메서드())
## 시퀀스 데이터
- 문자열 조회/탐색/검증
	- find(x) x 첫 위치, 없으면 -1
	- index(x) x 첫 위치, 없으면 오류
	- isalpha() 유니코드 문자인지 (하나라도 아니면 False)
	- isupper(), islower() 대소문자 여부 (하나랃 ㅗ아니면 False)
- 문자열 조작 (새 문자열 반환)
	- replace(old, new) 바꿀 대상 글자 -> 새 글자로 변환
	- strip(\[chars]) 공백/특정 문자 제거
	- split(sep=None, maxsplit=-1) 공백/특정 문자 기준으로 분리, 문자열의 리스트로 반환
	- 'separator'.join(iterable) 구분자로 iterable을 합침
	- capitalize() 가장 첫 번째 글자 대문자로 변경 (나머지는 소문자)
	- title() 띄어쓰기 기준으로 첫 글자 대문자, 나머지 소문자
	- upper(), lower() 모두 대소문자
	- swapcase() 대 ↔ 소 문자 변경
- 리스트 값 추가/삭제
	- append(x) 리스트 마지막에 항목 x 추가
	- extend(m) Iterable m의 모든 항목 리스트 끝에 추가 (+= 와 같다)
	- insert(i, x) 인덱스 i에 항목 x 삽입
	- remove(x) 가장 왼쪽(첫번째) x 제거, 존재x면 ValueError
	- pop() 가장 오른쪽(마지막) 항목 반환 후 제거
	- pop(i) 인덱스 i에 있는 항목 반환 후 제거
	- clear() 모든 항목 제거
- 리스트 탐색/정렬
	- index(x, start, end) 리스트 항목 중 가장 왼쪽 x 인덱스 반환
	- reverse() 리스트 순서 역순으로 변경(정렬x)
	- sort() 리스트 정렬 (key로 정렬할 기준 정할 수 있음, reverse=True 넣으면 반대로 정렬)
	- count(x) : x의 개수 반환
- 기타
	- 문자열에 포함된 문자들의 유형을 판별하는 메서드
		- isdecimal() : 문자열이 모두 숫자로만 이루어져 있어야 True
		- isdigit() : 유니코드 숫자도 인식 (① 이런거)
		- isnumeric() : 추가 유니코드 문자(분수/지수/루트 기호)도 인식
		- sorted(시퀀스) : 시퀀스 정렬 (str도 됨)
## 복사
### 변경 가능한 데이터 타입
- ex. 리스트
### 변경 불가능한 데이터 타입
- ex. integer
### 복사 유형
- 할당 : =을 이용한 복사는 객체 참조를 복사
- 얕은 복사
	- 리스트 슬라이싱 : 원본 객체와 독립적으로 존재
	- 2차원 리스트처럼 변경 가능 객체 안에 변경 가능 객체가 있는 경우
		- 각 리스트 주소는 다르지만 내부 리스트 주소는 같음 -> 함께 변경
- 깊은 복사
	- import copy
	- copy.deepcopy(리스트) : 내부 중첩된 객체까지 모두 새로운 객체 주소 참조
## 비시퀀스 데이터 구조
- 세트 메서드
	- add(x) 항목 x 추가, 이미 x 있으면 변화없음
	- clear() 모든 항목 제거
	- remove(x) 항목 x 제거, 없다면 Key error
	- pop() 랜덤하게 항목 반환, 해당 항목 제거
	- discard(x) 항목 x 제거
	- update(iterable) iterable요소 추가
- 세트 집합 메서드
	- set1.difference(set2) set1에는 있지만 set2에는 없는 항목으로 세트 생성 후 반환 (차집합)
	- set1.intersection(set2) set1과 set2 모두 들어있는 항목으로 세트 생성 후 반환(교집합)
	- set1.issubset(set2) set1 항목 모두 set2에 들어있으면 True(set1이 set2의 부분집합)
	- set1.issuperset(set2) set1이 set2 항목 모두 포함하면 True(set2가 set1의 부분집합)
	- set1.union(set2) set1 또는 set2에 들어있는 항목으로 세트 생성 후 반환(합집합)
- 딕셔너리
	- clear() 모든 키/값 쌍 제거
	- get(k) 키 k에 연결된 값 반환(k 없으면 None)
	- get(k, v) 키 k에 연결된 값 반환(k없으면 기본값 v 반환)
	- keys() 딕셔너리의 키를 모은 객체 반환
	- values() 딕셔너리의 값을 모은 객체 반환
	- items() 딕셔너리의 키/값 쌍을 모은 객체 반환
	- pop(k) 키k제거, 연결됐던 값 반환(없으면 오류)
	- pop(k, v) 키 k 제거, 연결됐던 값 반환(없으면 v 반환)
	- setdefault(k) 키 k와 연결된 값 반환 (없으면 None)
	- setdefault(k,v) 키 k와 연결된 값 반환(없으면 v와 연결한 k 추가 후 v 반환)
	- update(other) other내 각 키에 대해 D에 있는 키면 other에있는 값으로 대체, 없는 키면 키/값 쌍 D에 추가
		- 여러 개 한번에 가능
## 해시 테이블
: 해시 함수를 사용하여 변환한 값을 색인으로 삼아 키와 데이터를 저장하는 자료구조
*데이터를 효율적으로 저장하고 검색하기 위해 사용*
- 해시
	- 임의의 크기를 가진 데이터를 고정된 크기의 고유한 값으로 변환
	- 데이터 식별에 사용
		- '지문'과 같은 역할
		- 데이터를 고유하게 식별
	- 파이썬에서 해시 함수 사용하여 데이터를 해시 값으로 변환, 해시 값은 정수로 표현
- 해시 함수
	- 임의의 길이의 데이터를 입력 받아 고정된 길이의 데이터 출력하는 함수
	- 주로 해시테이블 자료구조에 사용
	- 매우 빠른 데이터 검색을 위한 컴퓨터 소프트웨어에서 유용하게 사용
- set의 요소&dictionary의 키와 해시테이블 관계
	- 세트의 요소와 딕셔너리의 키는 해시 테이블을 이용하여 중복되지않는 고유한 값 저장
	- 세트 내 각 요소는 해시 함수를 통해 해시 값으로 변환, 이 해시 값을 기반으로 해시 테이블에 저장
	- 딕셔너리의 키도 고유해야 하므로 키를 해시함수를 통해 변환 후 테이블에 저장
		→ 딕셔너리의 키는 매우 빠른 탐색 속도 제공, 중복된 값 허용 x
- [!] 정수 값 자체가 곧 해시 값임 (정수만 저장하면 반환 순서가 항상 정해져 있다)
	- 문자열은 매번 반환값이 다름
- hashable
	- hash() 함수의 인자로 전달해서 결과를 반환받을 수 있는 객체를 hashable이라 함
	- 대부분의 불변형 데이터는 hashable
	- tuple의 경우, 불변형이지만 해시 불가능한 객체를 참조할때는 tuple 자체도 해시 불가능해짐
	- 가변형 객체가 hashable하지 않은 이유 
		- 값이 변경될 수 있기 때문에 동일한 객체에 대한 해시 값이 변경될 가능성이 있음 → 무결성 유지 불가
		- 가변형 객체가 변경되면 해시 값도 변경, 같은 객체에 대한 서로 다른 해시 값이 반환될수 있음 → 해시 값 일관성 유지 x
	- hashable 객체가 필요한 이유
		1. 해시 테이블 기반 자료 구조 사용
		2. 불변성을 통한 일관된 해시 값
		3. 안전성과 예측 가능성 유지
# 백준 10989번 [수 정렬하기 3](https://www.acmicpc.net/problem/10989)
>[!NOTE] 
>N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.
>
>메모리 제한 8MB (python)
```python
import sys

N = int(sys.stdin.readline())
count = [0] * (10001)

for i in range(N):
    n = int(sys.stdin.readline())
    count[n] += 1

for i in range(len(count)):
    while count[i] > 0:
        print(i)
        count[i] -= 1
```
- [계수 정렬(Counting Sort) 알고리즘](../Algorithm/Counting_Sort.md)으로 푸는 문제
- list.sort() 사용했는데 메모리 초과
- 계수 정렬을 이용하며 리스트를 두개 이상 사용했더니 메모리 초과