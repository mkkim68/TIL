# 응용 계층
## 1. DNS와 지원
- 도메인 네임: 메시지 송수신 대상 파악에 사용
- URL: 위치 기반 식별자
- URN: 이름 기반 식별자
### 도메인 네임과 네임 서버
- 모든 호스트의 IP 주소를 기억하고 있기 어렵고 IP 주소는 언제든 바뀔 수 있음
	- 도메인 네임 사용
	- ex. www.example.com
- 네임 서버: 도메인 네임, IP 주소 관리
	- DNS 서버: 도메인 네임을 관리하는 네임 서버
![](../../img/250127_1.png)
- www.example.com
	- 점을 기준으로 분류
	- 최상단: 루트 도메인
	- 최상위 도메인(TLD, Top-Level Domain): 마지막 부분
	- 2단계 도메인(Second Level Domain): 최상위 도메인의 하부 도메인
	- 전체 주소 도메인 네임(FQDN: Fully-Qualified Domain Name): 도메인 네임을 모두 포함하는 도메인 네임
	- 호스트 네임: FQDN의 첫 번째 부분 (www)
- 도메인 네임 시스템(DNS, Domain Name System): 분산된 도메인 네임에 대한 관리 체계
### 계층적 네임 서버
- 리졸빙: IP 주소를 모르는 상태에서 도메인 네임에 대응되는 IP 주소를 알아내는 과정
- 로컬 네임 서버: 클라이언트와 맞닿아 있는 네임 서버
	- 클라이언트가 도메인 네임을 통해 IP 주소를 알아내고자 할 때 가장 먼저 찾게 되는 네임 서버
	- 보통 ISP에서 할당하지만 공개 DNS 서버 사용하기도 함
- 루트 네임 서버: 로컬 네임 서버가 대응되는 IP 주소를 모를 때 여기로 해당 도메인 네임을 질의하게 됨
- TLD 네임 서버: TLD를 관리하는 네임 서버, 질의에 대해 TLD의 하위 도메인 네임을 관리하는 네임 서버 주소를 반환 가능
- 책임 네임 서버: 특정 도메인 영역을 관리하는 네임 서버
	- 자신이 관리하는 도메인 영역에 대한 질의에 대해서는 다른 네임 서버에게 떠넘기지 않고 곧바로 답할 수 있는 네임 서버
- 재귀적 질의: 클라이언트가 로컬 네임 서버에게 도메인 네임을 질의하면, 로컬 네임 서버가 루트 네임 서버에게 질의하고, 루트 네임 서버가 TLD 네임 서버에게 질의하고, TLD 네임 서버가 다음 단계에 질의하는 과정 반복 -> 최종 응답 결과 역순으로 전달
![](../../img/250127_2.png)
- 반복적 질의: 클라이언트가 로컬 네임 서버에게 IP 주소를 알고 싶은 도메인 네임을 질의하면, 로컬 네임 서버는 루트 도메인 서버에게 질의해서 다음으로 질의할 네임 서버의 주소를 응답받고, 다음으로 TLD 네임 서버에게 질의해서 다음으로 질의할 네임 서버의 주소를 응답받는 과정을 반복하다가 최종 응답 결과를 클라이언트에게 알려 주는 방식
	- 위의 두 방식은 시간이 오래 걸리고 네트워크 메시지 수가 지나치게 늘어난다는 단점 존재
![](../../img/250127_3.png)
- DNS 캐시: 서버 과부화를 막기 위해 기존에 응답받은 결과를 임시로 저장했다가 추후 같은 질의에 이를 활용함
### 자원을 식별하는 URI
- 자원: 네트워크상의 메시지를 통해 주고받는 대상
- URI(Uniform Resource Identifier): 자원을 식별할 수 있는 정보
	- URL(Uniform Resource Locator): 위치로 식별
	- URN(Uniform Resource Name): 이름으로 식별
#### URL
- 인터넷 환경에서 자원 식별에 더 많이 활용
![](../../img/250127_4.png)
1. scheme: 자원에 접근하는 방법
   - 사용할 프로토콜
2. authority: 호스트를 특정할 수 있는 정보
   - IP 주소, 도메인 네임
3. path: 자원이 위치한 경로
   - 슬래시 기준 계층적으로 표현
4. query: 요청-응답 기반 프로토콜
   - 쿼리 문자열(쿼리 파라미터): 물음표로 시작되는 키=값 의 형태
   - 앰퍼샌드(&)를 사용하여 여러 쿼리 문자열 연결
5. fragment: 자원의 한 조각을 가리키기 위한 정보
   - 흔히 HTML 파일과 같은 자원에서 특정 부분을 가리키기 위해 사용
#### URN
- 자원에 고유한 이름을 붙이는 이름 기반 식별자
	- 자원의 위치와 무관하게 자원을 식별 가능하다는 장점
## 2. HTTP
### HTTP의 특성
- HTTP (Hypertext Transfer Protocol)
#### 1. 요청-응답 기반 프로토콜
- 클라이언트-서버 구조 기반의 요청-응답 프로토콜
#### 2. 미디어 독립적 프로토콜
- HTTP는 자원의 특성을 제한하지 않으며, 단지 자원과 상호 작용하는 데 사용할 수 있는 인터페이스 정의할 뿐
- 대부분의 자원을 URI로 식별
- 미디어 타입: HTTP에서 메시지로 주고받는 자원의 종류
	- MIME 타입(Multipurpose Internet Mail Extensions Type)
	- 슬래시 기준으로 '타입/서브타입' 형식으로 구성
		- 타입: 데이터의 유형
		- 서브타입: 주어진 타입에 대한 세부 유형
#### 3. 스테이트리스 프로토콜
- 상태를 유지하지 않는 스테이트리스 프로토콜
	- 서버가 HTTP 요청을 보낸 클라이언트와 관련된 상태를 기억하지 않는다는 의미
	- 독립적 요청으로 간주됨
- 상태 유지 x 특성의 장점
	- 모든 클라이언트의 상태 정보를 유지하는 것은 서버에 큰 부담
	- 서버가 여러 대일 경우 모든 서버가 모든 클라이언트의 상태를 유지할 경우, 클라이언트는 여러 서버를 동시에 이용하기 어려워짐 -> 특정 서버에 종속
- HTTP의 설계 목표
	- 확장성
	- 견고성
	- 스테이트리스여야 목표 달성 가능
#### 4. 지속 연결 프로토콜
- 지속 연결(킵 얼라이브): 하나의 TCP 연결 상태에서 여러 개의 요청-응답을 주고받을 수 있는 기술
### HTTP 메시지 구조
#### 시작 라인
- 요청 메시지 - '요청 라인', 응답 메시지 - '상태 라인'
- 요청 라인의 형식
	- 메서드: 클라이언트가 서버의 자원에 대해 수행할 작업의 종류
	- 요청 대상: 요청을 보낼 서버의 자원 (URI 경로 명시)
	- HTTP 버전: 'HTTP/버전' 으로 표기
- 응답 메시지일 경우 (상태 라인)
	- 상태 코드: 요청에 대한 결과를 나타내는 세 자리 정수
	- 이유 구문: 상태 코드에 대한 문자열 형태의 설명
	- ex. HTTP/1.1 200 OK
![](../../img/250127_5.png)
#### 필드 라인
- 0개 이상의 HTTP 헤더 명시
	- 헤더 라인
	- 통신에 필요한 부가 정보 의미
- 헤더 이름, 헤더 값
#### 메시지 본문
- HTTP 요청 or 응답 메시지에서 본문이 필요한 경우
### HTTP 메서드
| HTTP 메서드 | 설명                           |
| -------- | ---------------------------- |
| GET      | 자원을 습득하기 위한 메서드              |
| HEAD     | GET과 동일하나, 헤더만을 응답받는 메서드     |
| POST     | 서버로 하여금 특정 작업을 처리하게끔 하는 메서드  |
| PUT      | 자원을 대체하기 위한 메서드              |
| PATCH    | 자원에 대한 부분적 수정을 위한 메서드        |
| DELETE   | 자원을 삭제하기 위한 메서드              |
| CONNECT  | 자원에 대한 양방향 연결을 시작하는 메서드      |
| OPTIONS  | 사용 가능한 메서드 등 통신 옵션을 확인하는 메서드 |
| TRACE    | 자원에 대한 루프백 테스트를 수행하는 메서드     |
### HTTP 상태 코드
| 상태 코드 | 설명             |
| ----- | -------------- |
| 100번대 | 정보성 상태 코드      |
| 200번대 | 성공 상태 코드       |
| 300번대 | 리다이렉션 상태 코드    |
| 400번대 | 클라이언트 에러 상태 코드 |
| 500번대 | 서버 에러 상태 코드    |
#### 300번대: 리다이렉션 상태 코드
- 리다이렉션: 요청을 완서하기 위해 추가적인 조치가 필요한 상태
	- 영구적인 리다이렉션: 자원이 완전히 새로운 곳으로 이동하여 경로가 영구적으로 재지정되는 것
	- 일시적인 리다이렉션: 자원의 위치가 임시로 변경되었거나 임시로 사용할 URL이 필요한 경우에 주로 사용
## 3. HTTP 헤더와 HTTP 기반 기술
### HTTP 헤더
#### 요청 시 활용되는 HTTP 헤더
1. Host: 요청을 보낼 호스트를 나타내는 헤더 (주로 도메인 네임)
2. User-Agent: 웹 브라우저와 같이 HTTP 요청을 시작하는 클라이언트 측의 프로그램
3. Referer: 클라이언트가 요청을 보낼 때 머무르고 있던 URL 명시
4. Authorization: 클라이언트 인증 정보 (Base64 인코딩 값 사용)
#### 응답 시 활용되는 HTTP 헤더
1. Server: 요청을 처리하는 서버 측의 소프트웨어와 관련된 정보 명시
2. Allow: 클라이언트에게 허용된 HTTP 메서드 목록을 알려주기 위해 사용
3. Retry-After: 자원을 사용할 수 있는 날짜 혹은 시각 명시
4. Location: 클라이언트에게 자원의 위치를 알려 주기 위해 사용
5. WWW-Authenticate: 자원에 접근하기 위한 인증 방식 설명
- 인증을 수행하는 과정
	1. 인증되지 않은 클라이언트가 서버에 GET 요청 메시지를 전송
	2. 서버는 클라이언트에게 상태 코드 401과 함께 WWW-Authenticate 헤더를 통해 인증 방식을 알림
	3. 클라이언트는 사용자로부터 인증 정보(아이디, 비밀번호) 전달받음
	4. 사용자 아이디:비밀번호 를 Base64 인코딩한 값을 인증 정보로 삼은 Authorization 헤더를 통해 다시 GET 요청 메시지 전송
	5. 서버가 인증 정보 확인
	6. 인증이 유효하면 상태 코드 200 응답, 아니면 401
#### 요청과 응답 모두에서 활용되는 HTTP 헤더
1. Date: 메시지가 생성된 날짜와 시각에 관련된 정보를 담은 헤더
2. Connection: 클라이언트의 요청과 응답 간의 연결 방식을 설정하는 헤더
3. Content-Length: 본문의 바이트 단위 크기 나타냄
4. Content-Type, Content-Language, Content-Encoding (표현 헤더의 일종)
	- 미디어 타입
	- 언어 코드, 국가 코드
	- 메시지 본문 압축하거나 변환한 방식 명시
### 캐시
- 불필요한 대역폭 낭비와 응답 지연을 방지하기 위해 정보의 사본을 임시로 저장하는 기술
- 개인 전용 캐시: 웹 브라우저에 저장
- 공용 캐시: 클라이언트와 서버 사이에 위치한 중간 서버에 저장
#### 캐시 신선도 검사
- 캐시 신선도: 캐시된 사본 데이터가 얼마나 최신 원본 데이터와 유사한지
1. 날짜 기반 검사
2. 엔티티 태그 사용 (Etag)
	- Etag: 자원의 버전을 식별하기 위한 정보 (버전: 유의미한 변경 사항)
###  쿠키
- 서버에서 생성되어 클라이언트 측에 저장되는 데이터, <이름, 값> 쌍의 형태
### 콘텐츠 협상과 표현
- 콘텐츠 협상: 같은 URI에 대해 가장 적합한 '자원의 형태'를 제공하는 메커니즘
- 표현: 송수신 가능한 자원의 형태