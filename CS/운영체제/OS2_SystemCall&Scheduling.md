# 시스템 콜과 CPU 스케줄링 
## 운영체제
### 개념
- 운영체제란?
	- 시스템의 자원과 동작을 관리하는 소프트웨어
	- 하드웨어를 관리하고 응용 프로그램과 하드웨어 사이에서 인터페이스 역할을 하며 시스템의 동작을 제어하는 시스템 소프트웨어
### 목적
- CPU, 메모리, 디스크 등의 컴퓨터 하드웨어를 효율적으로 관리하는 것
	- 즉, 운영체제란 컴퓨터의 성능을 높이고 (performance) 사용자에게 편의 제공 (convenience)을 목적으로 하는 *컴퓨터 하드웨어 관리 프로그램*
### 실행 과정
![img](../../img/240723_1.PNG)
- 컴퓨터의 전원이 켜지면 CPU에서 ROM의 내용을 읽어옴
	- ROM에서 읽어오는 내용: 전원이 켜지면 가장 처음 실행되는 프로그램, POST (Power On Self Test)
- POST 작업이 끝나면 Boot Loader가 실행됨
	- Boot Loader: 하드디스크에 저장되어 있는 OS를 찾아서 RAM에 올림
- OS가 RAM 메모리에 올라가면 OS를 실행할 준비를 마친 것, 이러한 과정을 '부팅'이라 함
- 운영체제가 종료되는 시점: 전원이 꺼질 때
### 구조
![img](../../img/240723_2.PNG)
- 크게 커널과 쉘로 나뉨
	- 사용자가 명령어 입력
	- 쉘은 해당 명령어 해석 후 커널에 전달
	- 커널에서 해당 명령 수행 후 결과를 다시 쉘에 전달
	- 쉘은 전달받은 결과를 해석
	- 사용자가 명령어 입력 결과를 확인할 수 있도록 함
#### 커널(kernel)
- OS의 가장 주요한 부분, 메모리 위에 올라가 상주함
- 운영체제가 수행하는 모든 것이 담겨 있음
#### 쉘, 명령어 해석기(Shell, Command Interpreter)
- 사용자가 커널에 요청하는 명령어를 해석해 커널에 전달하고 그 결과를 출력함
### 위치
- 사용자 프로그램(Application): 운영체제 위에서 수행
	- 운영체제가 제공하는 자원만 사용 가능
	- 특정 운영체제에 맞춰서 만들어짐
### 하는 일
1. 프로세스 관리
2. 저장 장치 관리
   - 1차 저장장치 (Main Memory)
     - 프로세스에 할당하는 메모리 영역의 할당과 해제
     - 각 메모리 영역 간의 침범 방지
     - 메인 메모리의 효율적 활용을 위한 가상 메모리 기능
   - 2차 저장장치 (HDD, Flash Memory 등)
     - 파일 형식의 데이터 저장
     - 이런 파일 데이터 관리를 위한 파일 시스템을 OS에서 관리
3. 네트워킹
4. 사용자 관리
5. 디바이스 드라이버 : 특정 하드웨어나 장치를 제어하기 위한 커널의 일부분으로 동작하는 프로그램
## 시스템 콜의 개념과 종류
### 개념
- 시스템 호출(System call)은 운영 체제의 커널이 제공하는 서비스에 대해 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스
- 사용자 프로그램이 디스크 파일을 접근하거나 화면에 결과를 출력하는 등의 작업이 필요한 경우, 즉 사용자 프로그램이 특권 명령의 수행을 필요로 하는 경우, 운영체제에게 특권 명령의 대행을 요청하는 것
### 기능
- 각 시스템 콜에는 번호가 할당되고 시스템 콜 인터페이스는 *시스템 콜 번호와 시스템 콜 핸들러 함수 주소로 구성되는 시스템 콜 테이블*을 유지
- 운영체제는 자신의 커널 영역에서 해당 인덱스가 가리키는 주소에 저장되어 있는 루틴 수행
- 작업이 완료되면 CPU에게 인터럽트 발생시켜 수행 완료를 알림
### 필요한 이유
- 유저레벨의 프로그램은 유저레벨의 함수들 만으로는 많은 기능을 구현하기 어려움
	- 커널의 도움을 반드시 받아야 함
- 이런 작업은 응용프로그램으로 대표되는 유저 프로세스(User Process)에서 유저모드에서는 수행 불가능
- *반드시 커널에 관련된 것은 커널모드로 전환한 후에* 해당 작업을 수행할 권리가 생김
#### 권한은 왜 필요한가?
- 해커가 피해를 입히기 위해 악의적으로 시스템 콜을 사용하는 경우나 초보 사용자가 하드웨어 명령어를 잘 몰라서 아무렇게 함수를 호출했을 경우에 시스템 전체를 망가뜨릴 수도 있기 때문
### 유형
#### 프로세스 컨트롤
- 프로세스 생성 및 종료
- 메모리에 로드, 실행
- 프로세스 속성 값 확인, 지정
- wait 이벤트, signal 이벤트
- 메모리 할당
- 예) fork, wait, exec 등
#### 파일 매니지먼트
- 파일 생성, 파일 삭제
- 열기, 닫기
- 읽기, 쓰기. Reposition
- 파일 속성 값 확인, 지정
- 예) open, read, write, close 등
#### 디바이스 매니지먼트
- 디바이스 요청 및 해제
- 읽기, 쓰기, Reposition
- 디바이스 속성 확인, 지정
- 비 물리적인 디바이스 해제 및 장착
#### 정보 관리
- 시간 확인, 시간 지정
- 시스템 데이터 확인, 지정
- 프로세스, 파일, 디바이스 속성 가져오기
- 프로세스, 파일, 디바이스 속성 설정하기
#### 통신
- 커뮤니케이션 연결 생성 및 삭제
- 메시지 송신, 수신
- 상태 정보 전달
- remote 디바이스 해제 및 장착
#### 보안
- Permission 획득
- Permission 설정
### 유저 모드와 커널 모드
#### 유저 모드
- PC register가 사용자 프로그램이 올라가 있는 메모리 위치를 가리키고 있을 때 현재 사용자 프로그램을 수행중이라고 하며 CPU가 유저모드에서 수행중이라고 말한다.
#### 커널 모드
- PC register가 운영체제가 존재하는 부분을 가리키고 있다면 현재 운영체제의 코드를 수행중이라고 하며 CPU가 커널모드에서 수행중이라고 말한다.
### 일반 명령과 특권 명령
- CPU내에 모드 비트를 두어서 구분
- 0 - 커널모드/ 1- 유저모드
#### 일반 명령 (유저 모드)
- 메모리에서 자료를 읽어와서 CPU에서 계산하고 결과를 메모리에 쓰는 일련의 명령들, 모든 프로그램이 수행 가능하다.
#### 특권 명령 (커널 모드)
- 보안이 필요한 명령, 입출력 장치, 타이머 등 각종 장치에 접근하는 명령
## CPU 스케줄링 알고리즘 (FCFS, SJF, Priority, Round Robin)
### 스케줄링 Scheduling
- 컴퓨터 시스템의 모든 자원을 효율적으로 사용하기 위한 프로세스 관리 정책
- 하나의 프로세스가 끝나고 다음으로 수행할 프로세스를 선택할 때, 어떤 프로세스를 선택할지에 대한 기준이 되는 알고리즘을 *CPU 스케줄링 알고리즘*이라 함
### Scheduling Criteria
- 스케줄링의 성능을 비교하는 지표들
#### 사용자 관점
- Turnaround Time (반환 시간) ; 프로세스의 처음 시작 시간 부터 모든 작업을 끝내고 종료할 때 까지 걸린 시간 (CPU, waiting, I/O 등 모든 시간을 포함)
- Waiting Time (대기 시간) : CPU를 점유하기 위해 대기 열 (ready queue)에서 기다린 시간 (다른 큐에서 기다린 시간은 제외)
- Response Time (응답 시간) : 일반적으로 대화형 시스템에서 입력에 대한 반응 시간
#### 시스템 관점
-  CPU Utilization (CPU 이용률) : 총 경과 시간 대비 프로세스에 CPU가 이용되는 시간의 비율
- Throughout (처리율) : 단위 시간당 처리하는 작업의 수
### 선점/비선점
#### 선점
- 현재 CPU 시간을 할당 받아서 특정 프로세스가 실행 중일지라도, 필요에 의해 다른 프로세스가 CPU 시간을 강제적으로 빼앗을 수 있음
#### 비선점
- 현재 어떠한 프로세스가 CPU 시간을 할당받아 실행 되고 있다면 다른 프로세스는 현재 프로세스가 완료될 떄 까지 CPU 시간을 할당 받을 수 없음
### 알고리즘 종류
#### 1. FCFS, First Come First Served
- *먼저 요청 된 순서*대로 프로세스 실행
- 비선점
- 장점
	- 높은 자원 사용 효율
	- 일괄 처리 시스템에 적합
- 단점
	- 평균 *응답 시간 길어짐*
	- 대화형 시스템에 적합하지 않음
![img](../../img/240723_3.PNG)
- [!] Convoy Effect ; CPU 시간을 오래 사용하는 프로세스가 먼저 수행되는 동안, 나머지 프로세스들은 그만큼 오래 기다리는 것
#### 2. SJF, Shortest Job First
- *작업 시간이 짧은 순서대로* 프로세스 실행
- 작업 시간이 동일하다면 먼저 요청된 프로세스부터
- 선점, 비선점 모두 사용 가능
- 장점
	- 평균 대기 시간과 시스템 내의 대기 프로세스 수를 최소화하고, 다수의 프로세스에게 빠른 응답 제공됨
- 단점
	- *무한 대기*가 발생할 수 있음. 프로세스 생성 시 총 실행 시간에 대한 정확한 게산 불가능
- [!] 평균 대기 시간은 SJF 알고리즘이 가장 짧은 것이 이미 수학적으로 증명됨
	- 하지만 *비현실적인* 알고리즘이다.
	- 실제 컴퓨터 환경에서는 프로세스의 CPU 점유 시간을 알 수 없기 때문
#### 3. Priority, 우선 순위
- *우선순위가 높은 순서대로* CPU를 할당
- 우선순위가 같다면 FCFS로 결정
- 우선순위는 일반적으로 정수 값으로 나타내어지고, 작은 값이 우선순위가 높다 (Linux, Unix)
- 선점, 비선점
- 단점
	- 우선순위가 낮은 프로세스는 *영구 대기* 또는 *기아 현상*이 발생 가능
##### 우선 순위를 정하는 방법
- Internal (내부적 요소) : time limit, memory requirement, I/O to CPU burst 등
- External (외부적 요소) ; amount of funds being paid, political factors 등
##### Starvation, 기아 현상
- CPU의 점유를 오랫동안 하지 못하는 현상
##### Aging, 에이징
- 기아 현상 해결 방법 중 하나
- 프로세스가 ready queue에서 대기 중 일정 시간이 지나면 우선 순위를 일정량 높여주는 방법
#### 4. RR, Round Robin
- 모든 프로세스가 돌아가며 스케줄링 됨
- *시간 조각 (time slice, time quantum)* 이라는 작은 시간을 정의하고 이 시간이 경과하면 현재 프로세스를 대기 상태로 보내고 다음 프로세스를 수행
- 시분할 시스템에서 사용
- 응답 시간이 짧아 *대화형 시스템*에 적합
- 선점
- 단점
	- 알고리즘 성능이 *time-slice에 의존적*
	- 시간 조각의 크기가 크면 FCFS와 유사하지만, 크기가 작으면 잦은 *context switching*에 따른 오버헤드 발생
#### 5. 다단계 큐
- 프로세스를 성격에 따라 *여러 그룹으로 나누어 각 그룹별로 큐*를 두어 사용
- *큐마다 우선 순위 지정 가능*
![img](../../img/240723_4.PNG)
- 프로세스 그룹
	- System Process : 운영체제 커널 수준의 프로세스
	- Interactive Process : 유저 수준의 대화형 프로세스
	- Batch Process : 대화형 프로세스의 반대, 일정량을 한번에 처리하는 프로세스 (ex. 컴파일러)
	- Student Process
	- Interactive Editing Process
#### 6. 다단계 피드백 큐
![img](../../img/240723_5.PNG)
- 모든 프로세스는 가장 위 쪽 큐에서 대기
- 기다리는 시간이 너무 길어지면 아래의 큐로 프로세스를 옮겨서 대기 시간을 조정
- *각 큐마다 다른 스케줄링, 다른 우선순위* 등을 사용할 수 있음
- 만약 우선순위가 낮은 아래의 큐에 있는 프로세스에 기아 현상이 발생하면 우선순위가 높은 위쪽 큐로 옮길 수 있음
#### 7. SRTF, Shortest Remaining Time First
- SJF 알고리즘의 선점 방식
- 새로운 프로세스가 들어오면, 각 task들의 남은 수행 시간을 비교하여 가장 짧은 프로세스에게 CPU를 할당
- 단점
	- 프로세스 생성 시 총 실행 시간 추정에 대한 작업이 필요함
	- 잦은 선점이 발생하여 context switching 에 따른 오버헤드 발생 -> 프로세스들의 응답 시간 길어짐
- 현실적으로 구현하여 사용하기가 어렵다.